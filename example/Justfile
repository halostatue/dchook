# dchook example/integration Justfile

webhook_secret := justfile_dir() / "webhook_secret.txt"
client_secret := if env("CI", '') != '' { justfile_dir() / "client_secret.txt" } else { webhook_secret }
app_compose := justfile_dir() / "app/docker-compose.yml"
dchook_compose := justfile_dir() / "docker-compose.yml"
dchook_notify := justfile_dir() / "dchook-notify"
export HEALTH_URL := "http://localhost:7999/health"
export DCHOOK_URL := "http://localhost:7999/deploy"

# Default recipe - show available commands
@_default:
    just --list

# Generate a new webhook secret
generate:
    #!/usr/bin/env bash

    set -eo pipefail

    rm -f {{ webhook_secret }} {{ client_secret }}

    printf "Generating new webhook secret..."

    openssl rand -hex 32 > {{ webhook_secret }}
    chmod 0400 {{ webhook_secret }}

    if [[ -n "${CI}" ]]; then
      cp {{ webhook_secret }} {{ client_secret }}
    fi

    printf "\râœ“ New secret generated (permissions: 0400)\n"

# Start dchook and app
up: _build _build_image
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    docker compose -f {{ app_compose }} -p compose up -d >/dev/null 2>&1
    docker compose -f {{ dchook_compose }} up -d >/dev/null 2>&1

    echo "Waiting for dchook to be ready..."
    for i in $(seq 1 30); do
      if curl -sf "${HEALTH_URL}" >/dev/null 2>&1; then
        break
      fi

      if ((i >= 30)); then
        echo "dchook failed to start"
        docker compose -f {{ dchook_compose }} logs dchook
        exit 1
      fi

      sleep 1
    done

# Stop dchook and app
down:
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    docker compose -f {{ dchook_compose }} down >/dev/null 2>&1
    docker compose -f {{ app_compose }} -p compose down >/dev/null 2>&1

# Restart dchook and app
@restart: down up

# Show service logs
logs:
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    docker compose -f {{ dchook_compose }} logs dchook

# Test successful webhook
success:
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    export DCHOOK_SECRET_FILE={{ client_secret }}

    if {{ dchook_notify }} -q payload.json; then
      echo "âœ“ Successful dchook trigger"
    else
      echo "ð„‚ Error sending dchook trigger (exit code $?)"
      exit 1
    fi

    just logs

# Test rate limiting (send 2 requests quickly)
rate-limited:
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    export DCHOOK_SECRET_FILE={{ client_secret }}

    if {{ dchook_notify }} -q payload.json; then
      echo "âœ“ Successful dchook trigger"
    else
      status=$?
      echo "ð„‚ Error sending dchook trigger (exit code ${status})"
      exit ${status}
    fi

    if {{ dchook_notify }} -q payload.json; then
      echo "ð„‚ dchook trigger was not rate limited"
      exit 1
    else
      status=$?

      if ((status == 29)); then
        echo "âœ“ dchook trigger was rate limited"
      else
        echo "ð„‚ dchook trigger was not rate limited (exit code ${status})"
        exit ${status}
      fi
    fi

# Test failed authentication (wrong secret)
failed:
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    export DCHOOK_SECRET_FILE="{{ justfile_dir() }}/bad_secret.$$.txt"

    trap 'rm -f "${DCHOOK_SECRET_FILE}"' EXIT

    echo "wrong-secret" >"${DCHOOK_SECRET_FILE}"
    chmod 600 "${DCHOOK_SECRET_FILE}"

    if {{ dchook_notify }} -q payload.json; then
      echo "âœ— dchook trigger did not fail with bad secret"
      exit 1
    else
      status=$?

      if ((status == 41)); then
        echo "âœ“ dchook trigger failed with unauthorized (exit code ${status})"
      else
        echo "âœ— dchook trigger failed with unexpected exit code ${status} (expected 41)"
        exit ${status}
      fi
    fi

# Test ban (2 failed attempts trigger ban, 3rd gets 403)
banned:
    #!/usr/bin/env bash

    set -eo pipefail

    cd {{ justfile_dir() }}

    export DCHOOK_SECRET_FILE="{{ justfile_dir() }}/bad_secret.$$.txt"

    trap 'rm -f "${DCHOOK_SECRET_FILE}"' EXIT

    echo "wrong-secret" >"${DCHOOK_SECRET_FILE}"
    chmod 600 "${DCHOOK_SECRET_FILE}"

    echo "Sending first failed webhook..."
    if {{ dchook_notify }} -q payload.json; then
      echo "âœ— First request should have failed"
      exit 1
    else
      status=$?
      if ((status == 41)); then
        echo "âœ“ First request unauthorized (exit code ${status})"
      else
        echo "âœ— First request unexpected exit code ${status} (expected 41)"
        exit 1
      fi
    fi

    echo "Sending second failed webhook (triggers ban)..."
    if {{ dchook_notify }} -q payload.json; then
      echo "âœ— Second request should have failed"
      exit 1
    else
      status=$?
      if ((status == 41)); then
        echo "âœ“ Second request unauthorized (exit code ${status})"
      else
        echo "âœ— Second request unexpected exit code ${status} (expected 41)"
        exit 1
      fi
    fi

    echo "Sending third request (should be banned)..."
    if {{ dchook_notify }} -q payload.json; then
      echo "âœ— Third request should have been banned"
      exit 1
    else
      status=$?
      if ((status == 43)); then
        echo "âœ“ Third request forbidden/banned (exit code ${status})"
      else
        echo "âœ— Third request unexpected exit code ${status} (expected 43)"
        exit ${status}
      fi
    fi

    echo "âœ“ Ban test passed (ban lasts 1 hour, restart to clear: just restart)"

# Check service health
@health:
    echo "Checking dchook health..."
    curl -s {{ HEALTH_URL }}
    echo "\nChecking web service..."
    curl -s http://localhost:8081 | head -n 5

# Clean up everything
@clean: down
    rm -f {{ dchook_notify }} {{ webhook_secret }} {{ client_secret }}
    echo "Cleaned"

@_build:
    cd {{ justfile_dir() / ".." }} && go build -o {{ dchook_notify }} ./cmd/dchook-notify 2>&1 || { echo "Build failed"; exit 1; }

@_build_image:
    cd {{ justfile_dir() }} && docker build -t example-dchook:latest -f Dockerfile .. >/dev/null 2>&1 || { echo "Image build failed"; exit 1; }
